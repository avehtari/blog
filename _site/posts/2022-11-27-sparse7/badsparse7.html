<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.15">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Simpson">
<meta name="dcterms.date" content="2022-11-23">
<meta name="description" content="I work in R a lot so I should be used to weird syntax.">

<title>Un garçon pas comme les autres (Bayes) - Sparse matrices part 7: Making peace with those weird JAX loops</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Un garçon pas comme les autres (Bayes) - Sparse matrices part 7: Making peace with those weird JAX loops">
<meta property="og:description" content="I work in R a lot so I should be used to weird syntax.">
<meta property="og:image" content="https://dansblog.netlify.app/posts/2022-11-27-sparse7/elvira.jpg">
<meta property="og:site-name" content="Un garçon pas comme les autres (Bayes)">
<meta name="twitter:title" content="MCMC with the wrong acceptance probability">
<meta name="twitter:description" content="I work in R a lot so I should be used to weird syntax.">
<meta name="twitter:image" content="https://dansblog.netlify.app/posts/2022-11-27-sparse7/elvira.jpg">
<meta name="twitter:creator" content="@dan_p_simpson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Un garçon pas comme les autres (Bayes)</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About this blog</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/dan_p_simpson"><i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dpsimpson"><i class="bi bi-github" role="img" aria-label="github">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://dansblog.netlify.app"><i class="bi bi-person-circle" role="img" aria-label="website">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"><i class="bi bi-rss" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sparse matrices part 7: Making peace with those weird JAX loops</h1>
                  <div>
        <div class="description">
          <p>I work in R a lot so I should be used to weird syntax.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Fundamentals</div>
                <div class="quarto-category">MCMC</div>
                <div class="quarto-category">Bayes</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dan Simpson </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 23, 2022</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#control-flow-of-the-damned" id="toc-control-flow-of-the-damned" class="nav-link active" data-scroll-target="#control-flow-of-the-damned">Control flow of the damned</a></li>
  <li><a href="#building-a-jax-traceable-sparse-choleksy-factorisation" id="toc-building-a-jax-traceable-sparse-choleksy-factorisation" class="nav-link" data-scroll-target="#building-a-jax-traceable-sparse-choleksy-factorisation">Building a JAX-traceable sparse Choleksy factorisation</a>
  <ul class="collapse">
  <li><a href="#building-the-expression-graph" id="toc-building-the-expression-graph" class="nav-link" data-scroll-target="#building-the-expression-graph">Building the expression graph</a></li>
  </ul></li>
  <li><a href="#the-non-zero-pattern-of-l" id="toc-the-non-zero-pattern-of-l" class="nav-link" data-scroll-target="#the-non-zero-pattern-of-l">The non-zero pattern of <span class="math inline">\(L\)</span></a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>The time has come once more to resume my journey into sparse matrices. There’s been a bit of a pause, mostly because I realised that I didn’t know how to implement the sparse Cholesky factorisation in a JAX-traceable way. But not the time has come. It is time for me to get on top of JAX’s weird fucking loops.</p>
<p>And, along the way, I’m going to re-do the sparse Cholesky factorisation to make it, well, better.</p>
<section id="control-flow-of-the-damned" class="level2">
<h2 class="anchored" data-anchor-id="control-flow-of-the-damned">Control flow of the damned</h2>
<p>The first an most important rule of programming with JAX is that loops will break your heart. I mean, whatever, I guess they’re fine. But there’s a problem. Imagine the following function</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> f(x: jax.Array, n: Int) <span class="op">-&gt;</span> jax.Array:</span>
<span id="cb1-2"><a href="#cb1-2"></a>  out <span class="op">=</span> jnp.zeros_like(x)</span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-4"><a href="#cb1-4"></a>    out <span class="op">=</span> out <span class="op">+</span> x</span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is, basically, the worst implementation of multiplication by an integer that you can possibly imagine. This code will run fine in Python, but if you try to JIT compile it, JAX is gonna get <em>angry</em>. It will produce the machine code equivalent of</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">def</span> f_n(x):</span>
<span id="cb2-2"><a href="#cb2-2"></a>  out <span class="op">=</span> x</span>
<span id="cb2-3"><a href="#cb2-3"></a>  out <span class="op">=</span> out <span class="op">+</span> x</span>
<span id="cb2-4"><a href="#cb2-4"></a>  out <span class="op">=</span> out <span class="op">+</span> x</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="op">//</span> do this n times</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are two bad things happening here. First, note that the “compiled” code depends on <code>n</code> and will have to be compiled anew each time <code>n</code> changes. Secondly, the loop has been replaced by <code>n</code> copies of the loop body. This is called <em>loop unrolling</em> and, when used judiciously by a clever compiler, is a great way to speed up code. When done completely for <em>every</em> loop this is a nightmare and the corresponding code will take a geological amount of time to compile.</p>
<p>A similar thing<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> happens when you need to run autodiff on <code>f(x,n)</code>. For each <code>n</code> an expression graph is constructed that contains the unrolled for loop. This suggests that autodiff might also end up being quite slow (or, more problematically, more memory-hungry).</p>
<p>So the first rule of JAX is to avoid for loops. But if you can’t do that, there are three built-in loop structures that play nicely with JIT compilation and sometimes<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> differentiation. These three constructs are</p>
<ol type="1">
<li>A while loop <code>jax.lax.while(cond_func, body_func, init)</code></li>
<li>An accumulator <code>jax.lax.scan(body_func, init, xs)</code></li>
<li>A for loop <code>jax.lax.fori_loop(lower, upper, body_fun, init)</code></li>
</ol>
<p>Of those three, the first and third work mostly as you’d expect, while the second is a bit more hairy. The <code>while</code> function is roughly equivalent to</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> jax_lax_while_loop(cond_func, body_func, init):</span>
<span id="cb3-2"><a href="#cb3-2"></a>  x  <span class="op">=</span> init</span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="cf">while</span> cond_func(x):</span>
<span id="cb3-4"><a href="#cb3-4"></a>    x <span class="op">=</span> body_func(x)</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So basically it’s just a while loop. The thing that’s important is that it compiles down to a single XLA operation<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> instead of some unrolled mess.</p>
<p>One thing that is important to realise is that while loops are only forwards-mode differentiable, which means that it is <em>very</em> expensive<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> to compute gradients. The reason for this is that we simply do not know how long that loop actually is and so it’s impossible to build a fixed-size expression graph.</p>
<p>The <code>jax.lax.scan</code> function is probably the one that people will be least familiar with. That said, it’s also the one that is roughly “how a for loop should work”. The concept that’s important here is a for-loop with <em>carry over</em>. Carry over is information that changes from one step of the loop to the next. This is what separates us from a <code>map</code> statement, which would apply the same function independently to each element of a list.</p>
<p>The scan function looks like</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">def</span> jax_lax_scan(body_func, init, xs):</span>
<span id="cb4-2"><a href="#cb4-2"></a>  len_x0 <span class="op">=</span> <span class="bu">len</span>(x0)</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(<span class="bu">len</span>(x) <span class="op">==</span> len_x0 <span class="cf">for</span> x <span class="kw">in</span> xs):</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"All x must have the same length!!"</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a>  carry <span class="op">=</span> init</span>
<span id="cb4-6"><a href="#cb4-6"></a>  ys <span class="op">=</span> []</span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="cf">for</span> x <span class="kw">in</span> xs:</span>
<span id="cb4-8"><a href="#cb4-8"></a>    carry, y <span class="op">=</span> body_func(carry, x)</span>
<span id="cb4-9"><a href="#cb4-9"></a>    ys.append(y)</span>
<span id="cb4-10"><a href="#cb4-10"></a>  </span>
<span id="cb4-11"><a href="#cb4-11"></a>  <span class="cf">return</span> carry, np.stack(ys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A critically important limitation to <code>jax.lax.scan</code> is that is that every <code>x</code> in <code>xs</code> must have the same shape! This mean, for example, that</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>xs <span class="op">=</span> [[<span class="dv">1</span>], [<span class="dv">2</span>,<span class="dv">3</span>], [<span class="dv">4</span>], <span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>is not a valid argument. Like all limitations in JAX, this serves to make the code transformable into efficiently compiled code across various different processors.</p>
<p>For example, if I wanted to use <code>jax.lax.scan</code> on my example from before I would get</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> jax <span class="im">import</span> lax</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">from</span> jax <span class="im">import</span> numpy <span class="im">as</span> jnp</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">def</span> f(x, n):</span>
<span id="cb6-5"><a href="#cb6-5"></a>  init <span class="op">=</span> jnp.zeros_like(x)</span>
<span id="cb6-6"><a href="#cb6-6"></a>  xs <span class="op">=</span> jnp.repeat(x, n)</span>
<span id="cb6-7"><a href="#cb6-7"></a>  <span class="kw">def</span> body_func(carry, y):</span>
<span id="cb6-8"><a href="#cb6-8"></a>    val <span class="op">=</span> carry <span class="op">+</span> y</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="cf">return</span> (val, val)</span>
<span id="cb6-10"><a href="#cb6-10"></a>  </span>
<span id="cb6-11"><a href="#cb6-11"></a>  final, journey <span class="op">=</span> lax.scan(body_func, init, xs)</span>
<span id="cb6-12"><a href="#cb6-12"></a>  <span class="cf">return</span> (final, journey)</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a>final, journey <span class="op">=</span> f(<span class="fl">1.2</span>, <span class="dv">7</span>)</span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="bu">print</span>(final)</span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="bu">print</span>(journey)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>8.4
[1.2       2.4       3.6000001 4.8       6.        7.2       8.4      ]</code></pre>
</div>
</div>
<p>This translation is a bit awkward compared to the for loop but it’s the sort of thing that you get used to.</p>
<p>This function can be differentiated<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> and compiled. To differentiate it, I need a version that returns a scalar, which is easy enough to do with a lambda.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">from</span> jax <span class="im">import</span> jit, grad</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>f2 <span class="op">=</span> <span class="kw">lambda</span> x, n: f(x,n)[<span class="dv">0</span>]</span>
<span id="cb8-4"><a href="#cb8-4"></a>f2_grad <span class="op">=</span> grad(f2, argnums <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="bu">print</span>(f2_grad(<span class="fl">1.2</span>, <span class="dv">7</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>7.0</code></pre>
</div>
</div>
<p>The <code>argnums</code> option tells JAX that we are only differentiating wrt the first argument.</p>
<p>JIT compilation is a timy bit more delicate. If we try the natural thing, we are going to get an error.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>f_jit_bad <span class="op">=</span> jit(f)</span>
<span id="cb10-2"><a href="#cb10-2"></a>bad <span class="op">=</span> f_jit_bad(<span class="fl">1.2</span>, <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>ConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: Traced&lt;ShapedArray(int32[], weak_type=True)&gt;with&lt;DynamicJaxprTrace(level=0/1)&gt;
When jit-compiling jnp.repeat, the total number of repeats must be static. To fix this, either specify a static value for `repeats`, or pass a static value to `total_repeat_length`.
The error occurred while tracing the function f at /var/folders/08/4p5p665j4d966tr7nvr0v24c0000gn/T/ipykernel_83461/3851190413.py:4 for jit. This concrete value was not available in Python because it depends on the value of the argument 'n'.

See https://jax.readthedocs.io/en/latest/errors.html#jax.errors.ConcretizationTypeError</code></pre>
</div>
</div>
<p>In order to compile a function, JAX needs to know how big everything is. And right now it does not know what <code>n</code> is. This shows itself through the <code>ConcretizationTypeError</code>, which basically says that as JAX was looking through your code it found something it can’t manipulate. In this case, it was in the <code>jnp.repeat</code> function.</p>
<p>We can fix this problem by declaring this parameter <code>static</code>.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>f_jit <span class="op">=</span> jit(f, static_argnums<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="bu">print</span>(f_jit(<span class="fl">1.2</span>,<span class="dv">7</span>)[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>8.4</code></pre>
</div>
</div>
<p>A static parameter is a parameter value that is known at compile time. If we define <code>n</code> to be static, then the first time you call <code>f_jit(x, 7)</code> it will compile and then it will reuse the compiled code for any other value of <code>x</code>. If we then call <code>f_jit(x, 9)</code>, the code will <em>compile again</em>.</p>
<p>To see this, we can make use of a JAX oddity: if a function prints something<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, then it will only be printed upon compilation and never again. This means that we can’t do <em>debug by print</em>. But on the upside, it’s easy to check, when things are compiling.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">def</span> f2(x, n):</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="bu">print</span>(<span class="ss">f"compiling: n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="cf">return</span> f(x,n)[<span class="dv">0</span>]</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>f2_jit <span class="op">=</span> jit(f2, static_argnums<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="bu">print</span>(f2_jit(<span class="fl">1.2</span>,<span class="dv">7</span>))</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="bu">print</span>(f2_jit(<span class="fl">1.8</span>,<span class="dv">7</span>))</span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="bu">print</span>(f2_jit(<span class="fl">1.2</span>,<span class="dv">9</span>))</span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="bu">print</span>(f2_jit(<span class="fl">1.8</span>,<span class="dv">7</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>compiling: n = 7
8.4
12.6
compiling: n = 9
10.799999
12.6</code></pre>
</div>
</div>
<p>This is a perfectly ok solution as long as the static parameters don’t change very often. In our context, this is going to have to do with the sparsity pattern.</p>
<p>Finally, we can talk about <code>jax.lax.fori_loop</code>, the in-built for loop. This is basically a convenience wrapper for <code>jax.lax.scan</code> (when <code>lower</code> and <code>upper</code> are static) or <code>jax.lax.while</code> (when they are not). The Python pseudocode is</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">def</span> jax_lax_fori_loop(lower, upper, body_func, init):</span>
<span id="cb16-2"><a href="#cb16-2"></a>  out <span class="op">=</span> init</span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lower, upper):</span>
<span id="cb16-4"><a href="#cb16-4"></a>    out <span class="op">=</span> body_func(i, out)</span>
<span id="cb16-5"><a href="#cb16-5"></a>  <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To close out this bit where I repeat hte docs, there is also a traceable if/esle: <code>jax.lax.cond</code> which has the pseudocode</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">def</span> jax_lax_cond(pred, true_fun, false_fun, val):</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="cf">if</span> pred:</span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="cf">return</span> true_fun(val)</span>
<span id="cb17-4"><a href="#cb17-4"></a>  <span class="cf">else</span>:</span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="cf">return</span> false_fun(val)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="building-a-jax-traceable-sparse-choleksy-factorisation" class="level2">
<h2 class="anchored" data-anchor-id="building-a-jax-traceable-sparse-choleksy-factorisation">Building a JAX-traceable sparse Choleksy factorisation</h2>
<p>In order to build a JAX-traceable sparse Cholesky factorisation <span class="math inline">\(A = LL^T\)</span>, we are going to need to build up a few moving parts.</p>
<ol type="1">
<li><p>Build the elimination tree of <span class="math inline">\(A\)</span> and find the number of non-zeros in each column of <span class="math inline">\(L\)</span></p></li>
<li><p>Build the <em>symbolic factorisation</em><a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> of <span class="math inline">\(L\)</span> (aka the location of the non-zeros of <span class="math inline">\(L\)</span>)</p></li>
<li><p>Do the actual numerical decomposition.</p></li>
</ol>
<p>In the <a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html">previous post</a> we did not explictly form the elimination tree. Instead, I used dynamic memory allocation. This time I’m being more mature.</p>
<section id="building-the-expression-graph" class="level3">
<h3 class="anchored" data-anchor-id="building-the-expression-graph">Building the expression graph</h3>
<p>The elimination tree<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> <span class="math inline">\(\mathcal{T}_A\)</span> is a (forest of) rooted tree(s) that compactly represent the non-zero pattern of the Cholesky factor <span class="math inline">\(L\)</span>. In particular, the elmination tree has the property that, for any <span class="math inline">\(k &gt; j\)</span> , <span class="math inline">\(L_{kj} \neq 0\)</span> if and only if there is a path from <span class="math inline">\(j\)</span> to <span class="math inline">\(k\)</span> in the tree. Or, in the language of trees, <span class="math inline">\(L_{kj} \neq 0\)</span> if and only if <span class="math inline">\(j\)</span> is a descendant of <span class="math inline">\(k\)</span> in the tree <span class="math inline">\(\mathcal{T}_A\)</span>.</p>
<p>We can describe<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> <span class="math inline">\(\mathcal{T}_A\)</span> by listing the parent of each node. The parent node of <span class="math inline">\(j\)</span> in the tree is the smallest <span class="math inline">\(i &gt; j\)</span> with <span class="math inline">\(L_{ij} \neq 0\)</span>.</p>
<p>We can turn this into an algorithm. An efficent version, which is described in Tim Davies book takes about <span class="math inline">\(\mathcal{O(\text{nnz}(A))}\)</span> operations. But I’m going to program up a slower one that takes <span class="math inline">\(\mathcal{O(\text{nnz}(L))}\)</span> operations, but has the added benifit<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> of giving me the column counts for free.</p>
<p>To do this, we are going to walk the tree and dynamically add up the column counts as we go.</p>
<p>To start off, let’s do this in standard python so that we can see what the algorithm look like. The key concept is that if we write <span class="math inline">\(\mathcal{T}_{j-1}\)</span> as the elimination tree encoding the structure of<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> <code>L[:j, :j]</code>, then we can ask about how this tree connects with node <code>j</code>.</p>
<p>A theorem gives a very simple answer to this.</p>
<div id="thm-tree" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 </strong></span>If <span class="math inline">\(j &gt; i\)</span>, then <span class="math inline">\(A_{j,i} \neq 0\)</span> implies that <span class="math inline">\(i\)</span> is a descendant of <span class="math inline">\(j\)</span> in <span class="math inline">\(\mathcal{T}_A\)</span>. In particular, that means that there is a directed path in <span class="math inline">\(\mathcal{T}_A\)</span> from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
</div>
<p>This tells us that the connection between <span class="math inline">\(\mathcal{T}_{j-1}\)</span> and node <span class="math inline">\(j\)</span> is that for each non-zero elements <span class="math inline">\(i\)</span> of the <span class="math inline">\(j\)</span>th row of <span class="math inline">\(A\)</span>, we can walk $ must have a path in <span class="math inline">\(\mathcal{T}_{j-1}\)</span> from <span class="math inline">\(i\)</span> and we will eventually get to a node that has no parent in <span class="math inline">\(\{0,\ldots, j-1\}\)</span>. Because there <em>must</em> be a path from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> in <span class="math inline">\(T_j\)</span>, it means that the parent of this terminal node must be <span class="math inline">\(j\)</span>.</p>
<p>As with everything Cholesky related, this works because the algorithm procedes from left to right, which in this case means that the node label assocated with <em>any</em> descendent of <span class="math inline">\(j\)</span> is always less than <span class="math inline">\(j\)</span>.</p>
<p>The algorithm is then a fairly run-of-the-mill<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> tree traversal, where we keep track of where we have been so we don’t double count our columns.</p>
<p>Probably the most important thing here is that I am using the <em>full</em> sparse matrix rather than just its lower triangle. This is, basically, convenience. I need access to the left half of the <span class="math inline">\(j\)</span>th row of <span class="math inline">\(A\)</span>, which is conveniently the same as the top half of the <span class="math inline">\(j\)</span>th column. And sometimes you just don’t want to be dicking around with swapping between row- and column-based representations.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">def</span> etree_base(A_indices, A_indptr):</span>
<span id="cb18-4"><a href="#cb18-4"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>  parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb18-6"><a href="#cb18-6"></a>  mark <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb18-7"><a href="#cb18-7"></a>  col_count <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb18-8"><a href="#cb18-8"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb18-9"><a href="#cb18-9"></a>    mark[j] <span class="op">=</span> j</span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="cf">for</span> indptr <span class="kw">in</span> <span class="bu">range</span>(A_indptr[j], A_indptr[j<span class="op">+</span><span class="dv">1</span>]):</span>
<span id="cb18-11"><a href="#cb18-11"></a>      node <span class="op">=</span> A_indices[indptr]</span>
<span id="cb18-12"><a href="#cb18-12"></a>      <span class="cf">while</span> node <span class="op">&lt;</span> j <span class="kw">and</span> mark[node] <span class="op">!=</span> j:</span>
<span id="cb18-13"><a href="#cb18-13"></a>        <span class="cf">if</span> parent[node] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb18-14"><a href="#cb18-14"></a>          parent[node] <span class="op">=</span> j</span>
<span id="cb18-15"><a href="#cb18-15"></a>        mark[node] <span class="op">=</span> j</span>
<span id="cb18-16"><a href="#cb18-16"></a>        col_count[node] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>        node <span class="op">=</span> parent[node]</span>
<span id="cb18-18"><a href="#cb18-18"></a>  <span class="cf">return</span> (parent, col_count)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To convince ourselves this works, let’s run an example and compare the column counts we get to our previous method.</p>
<div class="cell" data-execution_count="14">
<details>
<summary>Some boilerplate from previous editions.</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="im">from</span> scipy <span class="im">import</span> sparse</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb19-3"><a href="#cb19-3"></a>    </span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="kw">def</span> make_matrix(n):</span>
<span id="cb19-6"><a href="#cb19-6"></a>  one_d <span class="op">=</span> sparse.diags([[<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">2</span>), [<span class="fl">2.</span>]<span class="op">*</span>n, [<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">2</span>)], [<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>])</span>
<span id="cb19-7"><a href="#cb19-7"></a>  A <span class="op">=</span> (sparse.kronsum(one_d, one_d) <span class="op">+</span> sparse.eye(n<span class="op">*</span>n))</span>
<span id="cb19-8"><a href="#cb19-8"></a>  A_csc <span class="op">=</span> A.tocsc()</span>
<span id="cb19-9"><a href="#cb19-9"></a>  A_csc.eliminate_zeros()</span>
<span id="cb19-10"><a href="#cb19-10"></a>  A_lower <span class="op">=</span> sparse.tril(A_csc, <span class="bu">format</span> <span class="op">=</span> <span class="st">"csc"</span>)</span>
<span id="cb19-11"><a href="#cb19-11"></a>  A_index <span class="op">=</span> A_lower.indices</span>
<span id="cb19-12"><a href="#cb19-12"></a>  A_indptr <span class="op">=</span> A_lower.indptr</span>
<span id="cb19-13"><a href="#cb19-13"></a>  A_x <span class="op">=</span> A_lower.data</span>
<span id="cb19-14"><a href="#cb19-14"></a>  <span class="cf">return</span> (A_index, A_indptr, A_x, A_csc)</span>
<span id="cb19-15"><a href="#cb19-15"></a></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="kw">def</span> _symbolic_factor(A_indices, A_indptr):</span>
<span id="cb19-17"><a href="#cb19-17"></a>  <span class="co"># Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.</span></span>
<span id="cb19-18"><a href="#cb19-18"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb19-19"><a href="#cb19-19"></a>  L_sym <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb19-20"><a href="#cb19-20"></a>  children <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb19-21"><a href="#cb19-21"></a>  </span>
<span id="cb19-22"><a href="#cb19-22"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb19-23"><a href="#cb19-23"></a>    L_sym[j] <span class="op">=</span> A_indices[A_indptr[j]:A_indptr[j <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb19-24"><a href="#cb19-24"></a>    <span class="cf">for</span> child <span class="kw">in</span> children[j]:</span>
<span id="cb19-25"><a href="#cb19-25"></a>      tmp <span class="op">=</span> L_sym[child][L_sym[child] <span class="op">&gt;</span> j]</span>
<span id="cb19-26"><a href="#cb19-26"></a>      L_sym[j] <span class="op">=</span> np.unique(np.append(L_sym[j], tmp))</span>
<span id="cb19-27"><a href="#cb19-27"></a>    <span class="cf">if</span> <span class="bu">len</span>(L_sym[j]) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb19-28"><a href="#cb19-28"></a>      p <span class="op">=</span> L_sym[j][<span class="dv">1</span>]</span>
<span id="cb19-29"><a href="#cb19-29"></a>      children[p] <span class="op">=</span> np.append(children[p], j)</span>
<span id="cb19-30"><a href="#cb19-30"></a>        </span>
<span id="cb19-31"><a href="#cb19-31"></a>  L_indptr <span class="op">=</span> np.zeros(n<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb19-32"><a href="#cb19-32"></a>  L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum([<span class="bu">len</span>(x) <span class="cf">for</span> x <span class="kw">in</span> L_sym])</span>
<span id="cb19-33"><a href="#cb19-33"></a>  L_indices <span class="op">=</span> np.concatenate(L_sym)</span>
<span id="cb19-34"><a href="#cb19-34"></a>  </span>
<span id="cb19-35"><a href="#cb19-35"></a>  <span class="cf">return</span> L_indices, L_indptr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># A_indices/A_indptr are the lower triangle, A is the entire matrix</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">37</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a>parent, col_count <span class="op">=</span> etree_base(A.indices, A.indptr)</span>
<span id="cb20-4"><a href="#cb20-4"></a>L_indices, L_indptr <span class="op">=</span> _symbolic_factor(A_indices, A_indptr)</span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a>true_parent <span class="op">=</span> L_indices[L_indptr[:<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb20-7"><a href="#cb20-7"></a>true_parent[np.where(np.diff(L_indptr[:<span class="op">-</span><span class="dv">1</span>]) <span class="op">==</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="bu">print</span>(<span class="bu">all</span>(x <span class="op">==</span> y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="bu">zip</span>(parent[:<span class="op">-</span><span class="dv">1</span>], true_parent)))</span>
<span id="cb20-9"><a href="#cb20-9"></a></span>
<span id="cb20-10"><a href="#cb20-10"></a>true_col_count  <span class="op">=</span> np.diff(L_indptr)</span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="bu">print</span>(<span class="bu">all</span>(true_col_count <span class="op">==</span> col_count))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True
True</code></pre>
</div>
</div>
<p>Excellent. Now we just need to convert it to JAX.</p>
<p>Or do we?</p>
<p>To be honest, this is a little pointless. This function is only run once per matrix so we won’t really get much speedup<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> from compilation.</p>
<p>Nevertheless, we might try.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a><span class="at">@jit</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">def</span> etree(A_indices, A_indptr):</span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="bu">print</span>(<span class="st">"(Re-)compiling etree(A_indices, A_indptr)"</span>)</span>
<span id="cb22-4"><a href="#cb22-4"></a>  <span class="co">## innermost while loop</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>  <span class="kw">def</span> body_while(val):</span>
<span id="cb22-6"><a href="#cb22-6"></a>  <span class="co">#  print(val)</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    j, node, parent, col_count, mark <span class="op">=</span> val</span>
<span id="cb22-8"><a href="#cb22-8"></a>    update_parent <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="dv">0</span>].at[x[<span class="dv">1</span>]].<span class="bu">set</span>(x[<span class="dv">2</span>])</span>
<span id="cb22-9"><a href="#cb22-9"></a>    parent <span class="op">=</span> lax.cond(lax.eq(parent[node], <span class="op">-</span><span class="dv">1</span>), update_parent, <span class="kw">lambda</span> x: x[<span class="dv">0</span>], (parent, node, j))</span>
<span id="cb22-10"><a href="#cb22-10"></a>    mark <span class="op">=</span> mark.at[node].<span class="bu">set</span>(j)</span>
<span id="cb22-11"><a href="#cb22-11"></a>    col_count <span class="op">=</span> col_count.at[node].add(<span class="dv">1</span>)</span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="cf">return</span> (j, parent[node], parent, col_count, mark)</span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a>  <span class="kw">def</span> cond_while(val):</span>
<span id="cb22-15"><a href="#cb22-15"></a>    j, node, parent, col_count, mark <span class="op">=</span> val</span>
<span id="cb22-16"><a href="#cb22-16"></a>    <span class="cf">return</span> lax.bitwise_and(lax.lt(node, j), lax.ne(mark[node], j))</span>
<span id="cb22-17"><a href="#cb22-17"></a></span>
<span id="cb22-18"><a href="#cb22-18"></a>  <span class="co">## Inner for loop</span></span>
<span id="cb22-19"><a href="#cb22-19"></a>  <span class="kw">def</span> body_inner_for(indptr, val):</span>
<span id="cb22-20"><a href="#cb22-20"></a>    j, A_indices, A_indptr, parent, col_count, mark <span class="op">=</span> val</span>
<span id="cb22-21"><a href="#cb22-21"></a>    node <span class="op">=</span> A_indices[indptr]</span>
<span id="cb22-22"><a href="#cb22-22"></a>    j, node, parent, col_count, mark <span class="op">=</span> lax.while_loop(cond_while, body_while, (j, node, parent, col_count, mark))</span>
<span id="cb22-23"><a href="#cb22-23"></a>    <span class="cf">return</span> (j, A_indices, A_indptr, parent, col_count, mark)</span>
<span id="cb22-24"><a href="#cb22-24"></a>  </span>
<span id="cb22-25"><a href="#cb22-25"></a>  <span class="co">## Outer for loop</span></span>
<span id="cb22-26"><a href="#cb22-26"></a>  <span class="kw">def</span> body_out_for(j, val):</span>
<span id="cb22-27"><a href="#cb22-27"></a>     A_indices, A_indptr, parent, col_count, mark <span class="op">=</span> val</span>
<span id="cb22-28"><a href="#cb22-28"></a>     mark <span class="op">=</span> mark.at[j].<span class="bu">set</span>(j)</span>
<span id="cb22-29"><a href="#cb22-29"></a>     j, A_indices, A_indptr, parent, col_count, mark <span class="op">=</span> lax.fori_loop(A_indptr[j], A_indptr[j<span class="op">+</span><span class="dv">1</span>], body_inner_for, (j, A_indices, A_indptr, parent, col_count, mark))</span>
<span id="cb22-30"><a href="#cb22-30"></a>     <span class="cf">return</span> (A_indices, A_indptr, parent, col_count, mark)</span>
<span id="cb22-31"><a href="#cb22-31"></a></span>
<span id="cb22-32"><a href="#cb22-32"></a>  <span class="co">## Body of code</span></span>
<span id="cb22-33"><a href="#cb22-33"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb22-34"><a href="#cb22-34"></a>  parent <span class="op">=</span> jnp.repeat(<span class="op">-</span><span class="dv">1</span>, n)</span>
<span id="cb22-35"><a href="#cb22-35"></a>  mark <span class="op">=</span> jnp.repeat(<span class="op">-</span><span class="dv">1</span>, n)</span>
<span id="cb22-36"><a href="#cb22-36"></a>  col_count <span class="op">=</span> jnp.repeat(<span class="dv">1</span>,  n)</span>
<span id="cb22-37"><a href="#cb22-37"></a>  init <span class="op">=</span> (A_indices, A_indptr, parent, col_count, mark)</span>
<span id="cb22-38"><a href="#cb22-38"></a>  A_indices, A_indptr, parent, col_count, mark <span class="op">=</span> lax.fori_loop(<span class="dv">0</span>, n, body_out_for, init)</span>
<span id="cb22-39"><a href="#cb22-39"></a>  <span class="cf">return</span> parent, col_count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Wow. That is <em>ugly</em>. But let’s see<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> if it works!</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>parent_jax, col_count_jax <span class="op">=</span> etree(A.indices, A.indptr)</span>
<span id="cb23-2"><a href="#cb23-2"></a></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="bu">print</span>(<span class="bu">all</span>(x <span class="op">==</span> y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="bu">zip</span>(parent_jax[:<span class="op">-</span><span class="dv">1</span>], true_parent)))</span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="bu">print</span>(<span class="bu">all</span>(true_col_count <span class="op">==</span> col_count_jax))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(Re-)compiling etree(A_indices, A_indptr)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>True</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>True</code></pre>
</div>
</div>
<p>Success!</p>
<p>I guess we could ask ourselves if we gained any speed.</p>
<p>Here is the pure python code.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="im">import</span> timeit</span>
<span id="cb27-2"><a href="#cb27-2"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">20</span>)</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree_base(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-6"><a href="#cb27-6"></a></span>
<span id="cb27-7"><a href="#cb27-7"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">50</span>)</span>
<span id="cb27-8"><a href="#cb27-8"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree_base(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">4</span>)</span>
<span id="cb27-13"><a href="#cb27-13"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree_base(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb27-14"><a href="#cb27-14"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 400: [0.0, 0.0, 0.0, 0.0, 0.0]
n = 2500: [0.03, 0.03, 0.03, 0.03, 0.03]
n = 16: [0.0, 0.0, 0.0, 0.0, 0.0]</code></pre>
</div>
</div>
<p>And here is our JAX’d and JIT’d code.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">20</span>)</span>
<span id="cb29-2"><a href="#cb29-2"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-4"><a href="#cb29-4"></a></span>
<span id="cb29-5"><a href="#cb29-5"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">50</span>)</span>
<span id="cb29-6"><a href="#cb29-6"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">200</span>)</span>
<span id="cb29-11"><a href="#cb29-11"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-13"><a href="#cb29-13"></a></span>
<span id="cb29-14"><a href="#cb29-14"></a>parent, col_count<span class="op">=</span> etree(A.indices, A.indptr)</span>
<span id="cb29-15"><a href="#cb29-15"></a>L_indices, L_indptr <span class="op">=</span> _symbolic_factor(A_indices, A_indptr)</span>
<span id="cb29-16"><a href="#cb29-16"></a></span>
<span id="cb29-17"><a href="#cb29-17"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">1000</span>)</span>
<span id="cb29-18"><a href="#cb29-18"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb29-19"><a href="#cb29-19"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(Re-)compiling etree(A_indices, A_indptr)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 400: [0.13, 0.0, 0.0, 0.0, 0.0]
(Re-)compiling etree(A_indices, A_indptr)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 2500: [0.13, 0.0, 0.0, 0.0, 0.0]
(Re-)compiling etree(A_indices, A_indptr)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 40000: [0.14, 0.02, 0.02, 0.02, 0.02]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>(Re-)compiling etree(A_indices, A_indptr)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 1000000: [2.11, 1.97, 1.97, 1.97, 1.98]</code></pre>
</div>
</div>
<p>You can see that there is some decent speedup. For the first three examples, the computation time is dominated by the compilation time, but we see when the matrix has a million unknowns the compilation time is negligible. At this scale it would probably be worth using the fancy algorithm. That said, it is probably not worth sweating a three second that is only done once when your problem is that big!</p>
</section>
</section>
<section id="the-non-zero-pattern-of-l" class="level2">
<h2 class="anchored" data-anchor-id="the-non-zero-pattern-of-l">The non-zero pattern of <span class="math inline">\(L\)</span></h2>
<p>Now that we know how many non-zeros there are, it’s time to populate them. Last time, I used some dynammic memory allocation to make this work, but JAX is certainly not going to allow me to do that. So instead I’m going to have to do the worst thing possible: think.</p>
<p>The way that we went about it last time was, to be honest, a bit arse-backwards. The main reason for this is that I did not have access to the elimination tree. But now we do, we can actually use it.</p>
<p>The trick is to slightly rearrange<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> the order of operations to get something that is more convenient for working out the structure.</p>
<p>Recall from last time that we used the <em>left-looking</em> Cholesky factorisation, which can be written in the dense case as</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">def</span> dense_left_cholesky(A):</span>
<span id="cb36-2"><a href="#cb36-2"></a>  n <span class="op">=</span> A.shape[<span class="dv">0</span>]</span>
<span id="cb36-3"><a href="#cb36-3"></a>  L <span class="op">=</span> np.zeros_like(A)</span>
<span id="cb36-4"><a href="#cb36-4"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb36-5"><a href="#cb36-5"></a>    L[j,j] <span class="op">=</span> np.sqrt(A[j,j] <span class="op">-</span> np.inner(L[j, :j], L[j, :j]))</span>
<span id="cb36-6"><a href="#cb36-6"></a>    L[(j<span class="op">+</span><span class="dv">1</span>):, j] <span class="op">=</span> (A[(j<span class="op">+</span><span class="dv">1</span>):, j] <span class="op">-</span> L[(j<span class="op">+</span><span class="dv">1</span>):, :j] <span class="op">@</span> L[j, :j].transpose()) <span class="op">/</span> L[j,j]</span>
<span id="cb36-7"><a href="#cb36-7"></a>  <span class="cf">return</span> L</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is not the only way to organise those operations. An alternative is the <em>up-looking</em> Cholesky factorisation, which can be implemented in the dense case as</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">def</span> dense_up_cholesky(A):</span>
<span id="cb37-2"><a href="#cb37-2"></a>  n <span class="op">=</span> A.shape[<span class="dv">0</span>]</span>
<span id="cb37-3"><a href="#cb37-3"></a>  L <span class="op">=</span> np.zeros_like(A)</span>
<span id="cb37-4"><a href="#cb37-4"></a>  L[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> np.sqrt(A[<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb37-5"><a href="#cb37-5"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n):</span>
<span id="cb37-6"><a href="#cb37-6"></a>    <span class="co">#if i &gt; 0:</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>    L[i, :i] <span class="op">=</span> (np.linalg.solve(L[:i, :i], A[:i,i])).transpose()</span>
<span id="cb37-8"><a href="#cb37-8"></a>    L[i, i] <span class="op">=</span> np.sqrt(A[i,i] <span class="op">-</span> np.inner(L[i, :i], L[i, :i]))</span>
<span id="cb37-9"><a href="#cb37-9"></a>  <span class="cf">return</span> L</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is quite a different looking beast! It scans row by row rather than column by column. And while the left-looking algorithm is based on matrix-vector multiplies, the up-looking algorithm is based on triangular solves. So maybe we should pause for a moment to check that these are the same algorithm!</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a>A <span class="op">=</span> np.random.rand(<span class="dv">15</span>, <span class="dv">15</span>)</span>
<span id="cb38-2"><a href="#cb38-2"></a>A <span class="op">=</span> A <span class="op">+</span> A.transpose()</span>
<span id="cb38-3"><a href="#cb38-3"></a>A <span class="op">=</span> A.transpose() <span class="op">@</span> A <span class="op">+</span> <span class="dv">1</span><span class="op">*</span>np.eye(<span class="dv">15</span>)</span>
<span id="cb38-4"><a href="#cb38-4"></a></span>
<span id="cb38-5"><a href="#cb38-5"></a>L_left <span class="op">=</span> dense_left_cholesky(A)</span>
<span id="cb38-6"><a href="#cb38-6"></a>L_up <span class="op">=</span> dense_up_cholesky(A)</span>
<span id="cb38-7"><a href="#cb38-7"></a></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="bu">print</span>(<span class="bu">round</span>(<span class="bu">sum</span>(<span class="bu">sum</span>(<span class="bu">abs</span>((L_left <span class="op">-</span> L_up)[:])))),<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0 2</code></pre>
</div>
</div>
<p>They are the same!!</p>
<p>The reason for considering the up-looking algorithm is that it gives a slightly nicer description of the non-zeros of row <code>i</code>, which will let us find the location of the non-zeros in the whole matrix. In particular, the non-zeros to the left of the diagonal on row <code>i</code> correspond to the non-zero indices of the solution to the lower triangular linear system<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> <span class="math display">\[
L_{1:(i-1),1:(i-1)} x^{(i)} = A_{1:i-1, i}.
\]</span> Because <span class="math inline">\(A\)</span> is sparse, this is a system of <span class="math inline">\(\operatorname{nnz}(A_{1:i-1,i})\)</span> linear equations, rather than <span class="math inline">\((i-1)\)</span> equations that we would have in the dense case. That means that the sparsity pattern of <span class="math inline">\(x^{(i)}\)</span> will be the union of the sparsity patterns of the columns of <span class="math inline">\(L_{1:(i-1),1:(i-1)}\)</span> that correspond to the non-zero entries of <span class="math inline">\(A_{1:i-1, i}\)</span>.</p>
<p>This means two things. Firstly, if <span class="math inline">\(A_{ji}\neq 0\)</span>, then <span class="math inline">\(x^{(i)}_j \neq 0\)</span>. Secondly, if $x^{(i)}_j $ <em>and</em> <span class="math inline">\(L_{kj}\neq 0\)</span>, then <span class="math inline">\(x_k \neq 0\)</span>. These two facts give us a way of finding the non-zero set of <span class="math inline">\(x^{(i)}\)</span> if we remember just one more fact: a definition of the elimination tree is that <span class="math inline">\(L_{kj} \neq 0\)</span> if <span class="math inline">\(j\)</span> is a descendent of <span class="math inline">\(k\)</span> in the elimination tree.</p>
<p>This reduces the problem of finding the non-zero elements of <span class="math inline">\(x^{(i)}\)</span> to the problem of finding all of the descendents of <span class="math inline">\(\{j: A_{ji} \neq 0\}\)</span> in the subtree <span class="math inline">\(\mathcal{T}_{i-1}\)</span>. And if there is one thing that people who are ok at programming are <em>excellent</em> at it is walking down a damn tree.</p>
<p>So let’s do that. Well, I’ve already done it. In fact, that was how I found the column counts in the first place! With this interpretation, the outer loop is taking us across the rows. And once I am in row <code>j</code><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>, I then find a starting node <code>node</code> (which is a non-zero in <span class="math inline">\(A_{1:(i-1),i}\)</span>) and I walk along that node checking each time if I’ve actually seen that node<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> before. If I haven’t seen it before, I added one to the column count of column <code>node</code><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.</p>
<p>To allocate the non-zero structure, I just need to replace that counter increment with an assignment.</p>
<p>We will do the pure python version first.</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">def</span> symbolic_cholesky_base(A_indices, A_indptr, parent, col_count):</span>
<span id="cb40-2"><a href="#cb40-2"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>  col_ptr <span class="op">=</span> np.repeat(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb40-4"><a href="#cb40-4"></a>  col_ptr[<span class="dv">1</span>:] <span class="op">+=</span> np.cumsum(col_count) </span>
<span id="cb40-5"><a href="#cb40-5"></a>  L_indices <span class="op">=</span> np.zeros(<span class="bu">sum</span>(col_count), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb40-6"><a href="#cb40-6"></a>  L_indptr <span class="op">=</span> np.zeros(n<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb40-7"><a href="#cb40-7"></a>  L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum(col_count)</span>
<span id="cb40-8"><a href="#cb40-8"></a>  mark <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb40-9"><a href="#cb40-9"></a></span>
<span id="cb40-10"><a href="#cb40-10"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb40-11"><a href="#cb40-11"></a>    mark[i] <span class="op">=</span> i</span>
<span id="cb40-12"><a href="#cb40-12"></a>    L_indices[L_indptr[i]] <span class="op">=</span> i</span>
<span id="cb40-13"><a href="#cb40-13"></a></span>
<span id="cb40-14"><a href="#cb40-14"></a>    <span class="cf">for</span> indptr <span class="kw">in</span> <span class="bu">range</span>(A_indptr[i], A_indptr[i<span class="op">+</span><span class="dv">1</span>]):</span>
<span id="cb40-15"><a href="#cb40-15"></a>      node <span class="op">=</span> A_indices[indptr]</span>
<span id="cb40-16"><a href="#cb40-16"></a>      <span class="cf">while</span> node <span class="op">&lt;</span> i <span class="kw">and</span> mark[node] <span class="op">!=</span> i:</span>
<span id="cb40-17"><a href="#cb40-17"></a>        mark[node] <span class="op">=</span> i</span>
<span id="cb40-18"><a href="#cb40-18"></a>        L_indices[col_ptr[node]] <span class="op">=</span> i</span>
<span id="cb40-19"><a href="#cb40-19"></a>        col_ptr[node] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb40-20"><a href="#cb40-20"></a>        node <span class="op">=</span> parent[node]</span>
<span id="cb40-21"><a href="#cb40-21"></a>  </span>
<span id="cb40-22"><a href="#cb40-22"></a>  <span class="cf">return</span> (L_indices, L_indptr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Does it work?</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">157</span>)</span>
<span id="cb41-2"><a href="#cb41-2"></a>parent, col_count <span class="op">=</span> etree_base(A.indices, A.indptr)</span>
<span id="cb41-3"><a href="#cb41-3"></a></span>
<span id="cb41-4"><a href="#cb41-4"></a>L_indices, L_indptr <span class="op">=</span> symbolic_cholesky_base(A.indices, A.indptr, parent, col_count)</span>
<span id="cb41-5"><a href="#cb41-5"></a>L_indices_true, L_indptr_true <span class="op">=</span> _symbolic_factor(A_indices, A_indptr)</span>
<span id="cb41-6"><a href="#cb41-6"></a></span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="bu">print</span>(<span class="bu">all</span>(x<span class="op">==</span>y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="bu">zip</span>(L_indices, L_indices_true)))</span>
<span id="cb41-8"><a href="#cb41-8"></a><span class="bu">print</span>(<span class="bu">all</span>(x<span class="op">==</span>y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="bu">zip</span>(L_indptr, L_indptr_true)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True
True</code></pre>
</div>
</div>
<p>Fabulosa!</p>
<p>Now let’s do the compiled version.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="at">@partial</span>(jit, static_argnums <span class="op">=</span> (<span class="dv">4</span>,))</span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="kw">def</span> symbolic_cholesky(A_indices, A_indptr, L_indptr, parent, nnz <span class="op">=</span> L_indptr[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb43-4"><a href="#cb43-4"></a>  </span>
<span id="cb43-5"><a href="#cb43-5"></a>  <span class="co">## innermost while loop</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>  <span class="kw">def</span> body_while(val):</span>
<span id="cb43-7"><a href="#cb43-7"></a>    <span class="bu">print</span>(<span class="st">"compile while"</span>)</span>
<span id="cb43-8"><a href="#cb43-8"></a>  <span class="co">#  print(val)</span></span>
<span id="cb43-9"><a href="#cb43-9"></a>    i, L_indices, L_indptr, node, parent, col_ptr, mark <span class="op">=</span> val</span>
<span id="cb43-10"><a href="#cb43-10"></a>    mark <span class="op">=</span> mark.at[node].<span class="bu">set</span>(i)</span>
<span id="cb43-11"><a href="#cb43-11"></a>    p <span class="op">=</span> col_ptr[node]</span>
<span id="cb43-12"><a href="#cb43-12"></a>    L_indices <span class="op">=</span> L_indices.at[p].<span class="bu">set</span>(i)</span>
<span id="cb43-13"><a href="#cb43-13"></a>    col_ptr <span class="op">=</span> col_ptr.at[node].add(<span class="dv">1</span>)</span>
<span id="cb43-14"><a href="#cb43-14"></a>    <span class="cf">return</span> (i, L_indices, L_indptr, parent[node], parent, col_ptr, mark)</span>
<span id="cb43-15"><a href="#cb43-15"></a></span>
<span id="cb43-16"><a href="#cb43-16"></a>  <span class="kw">def</span> cond_while(val):</span>
<span id="cb43-17"><a href="#cb43-17"></a>    i, L_indices, L_indptr, node, parent, col_ptr, mark <span class="op">=</span> val</span>
<span id="cb43-18"><a href="#cb43-18"></a>    <span class="cf">return</span> lax.bitwise_and(lax.lt(node, i), lax.ne(mark[node], i))</span>
<span id="cb43-19"><a href="#cb43-19"></a></span>
<span id="cb43-20"><a href="#cb43-20"></a>  <span class="co">## Inner for loop</span></span>
<span id="cb43-21"><a href="#cb43-21"></a>  <span class="kw">def</span> body_inner_for(indptr, val):</span>
<span id="cb43-22"><a href="#cb43-22"></a>    <span class="bu">print</span>(<span class="st">"compile inner for"</span>)</span>
<span id="cb43-23"><a href="#cb43-23"></a>    i, A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark <span class="op">=</span> val</span>
<span id="cb43-24"><a href="#cb43-24"></a>    node <span class="op">=</span> A_indices[indptr]</span>
<span id="cb43-25"><a href="#cb43-25"></a>    i, L_indices, L_indptr, node, parent, col_ptr, mark <span class="op">=</span> lax.while_loop(cond_while, body_while, (i, L_indices, L_indptr, node, parent, col_ptr, mark))</span>
<span id="cb43-26"><a href="#cb43-26"></a>    <span class="cf">return</span> (i, A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark)</span>
<span id="cb43-27"><a href="#cb43-27"></a>  </span>
<span id="cb43-28"><a href="#cb43-28"></a>  <span class="co">## Outer for loop</span></span>
<span id="cb43-29"><a href="#cb43-29"></a>  <span class="kw">def</span> body_out_for(i, val):</span>
<span id="cb43-30"><a href="#cb43-30"></a>     <span class="bu">print</span>(<span class="st">"compile outer for"</span>)</span>
<span id="cb43-31"><a href="#cb43-31"></a>     A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark <span class="op">=</span> val</span>
<span id="cb43-32"><a href="#cb43-32"></a>     mark <span class="op">=</span> mark.at[i].<span class="bu">set</span>(i)</span>
<span id="cb43-33"><a href="#cb43-33"></a>     L_indices <span class="op">=</span> L_indices.at[L_indptr[i]].<span class="bu">set</span>(i)</span>
<span id="cb43-34"><a href="#cb43-34"></a>     i, A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark <span class="op">=</span> lax.fori_loop(A_indptr[i], A_indptr[i<span class="op">+</span><span class="dv">1</span>], body_inner_for, (i, A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark))</span>
<span id="cb43-35"><a href="#cb43-35"></a>     <span class="cf">return</span> (A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark)</span>
<span id="cb43-36"><a href="#cb43-36"></a></span>
<span id="cb43-37"><a href="#cb43-37"></a>  <span class="co">## Body of code</span></span>
<span id="cb43-38"><a href="#cb43-38"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb43-39"><a href="#cb43-39"></a>  col_ptr <span class="op">=</span> L_indptr.copy() <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb43-40"><a href="#cb43-40"></a>  L_indices <span class="op">=</span> jnp.zeros(nnz, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb43-41"><a href="#cb43-41"></a>  </span>
<span id="cb43-42"><a href="#cb43-42"></a>  mark <span class="op">=</span> jnp.repeat(<span class="op">-</span><span class="dv">1</span>, n)</span>
<span id="cb43-43"><a href="#cb43-43"></a>  </span>
<span id="cb43-44"><a href="#cb43-44"></a>  init <span class="op">=</span> (A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark)</span>
<span id="cb43-45"><a href="#cb43-45"></a>  A_indices, A_indptr, L_indices, L_indptr, parent, col_ptr, mark <span class="op">=</span> lax.fori_loop(<span class="dv">0</span>, n, body_out_for, init)</span>
<span id="cb43-46"><a href="#cb43-46"></a>  <span class="cf">return</span> L_indices</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s check it works</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a><span class="im">import</span> jax </span>
<span id="cb44-2"><a href="#cb44-2"></a>parent, col_count <span class="op">=</span> etree(A.indices, A.indptr)</span>
<span id="cb44-3"><a href="#cb44-3"></a>L_indptr <span class="op">=</span> np.zeros(A.shape[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb44-4"><a href="#cb44-4"></a>L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum(col_count)</span>
<span id="cb44-5"><a href="#cb44-5"></a></span>
<span id="cb44-6"><a href="#cb44-6"></a></span>
<span id="cb44-7"><a href="#cb44-7"></a>L_indices<span class="op">=</span> symbolic_cholesky(A_indices, A_indptr, L_indptr, parent, nnz <span class="op">=</span> L_indptr[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb44-8"><a href="#cb44-8"></a>L_indices_true, L_indptr_true <span class="op">=</span> _symbolic_factor(A_indices, A_indptr)</span>
<span id="cb44-9"><a href="#cb44-9"></a></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="bu">print</span>(<span class="bu">all</span>(x<span class="op">==</span>y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="bu">zip</span>(L_indices, L_indices_true)))</span>
<span id="cb44-11"><a href="#cb44-11"></a><span class="bu">print</span>(<span class="bu">all</span>(x<span class="op">==</span>y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="bu">zip</span>(L_indptr, L_indptr_true)))</span>
<span id="cb44-12"><a href="#cb44-12"></a></span>
<span id="cb44-13"><a href="#cb44-13"></a><span class="bu">print</span>(jax.make_jaxpr(partial(symbolic_cholesky,A.indices, A.indptr, parent, col_count))())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(Re-)compiling etree(A_indices, A_indptr)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>compile outer for
compile inner for
compile while</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>False
True
compile outer for
compile inner for
compile while
{ lambda a:i32[121989] b:i32[24650] c:i32[24649] d:i32[24649]; . let
    e:i32[1935334] = xla_call[
      call_jaxpr={ lambda ; f:i32[121989] g:i32[24650] h:i32[24649] i:i32[24649]. let
          j:i32[24649] = copy h
          k:i32[24649] = add j 1
          l:i32[1935334] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1935334,)
          ] 0
          m:i32[1] = reshape[dimensions=None new_sizes=(1,)] -1
          n:i32[1,1] = broadcast_in_dim[broadcast_dimensions=(0,) shape=(1, 1)] m
          o:i32[1,1,1,1] = reshape[dimensions=None new_sizes=(1, 1, 1, 1)] n
          p:i32[1,1,1] = squeeze[dimensions=(2,)] o
          q:i32[1,1,24649,1] = broadcast_in_dim[
            broadcast_dimensions=(0, 1, 3)
            shape=(1, 1, 24649, 1)
          ] p
          r:i32[1,24649] = reshape[dimensions=None new_sizes=(1, 24649)] q
          s:i32[24649] = reshape[dimensions=None new_sizes=(24649,)] r
          _:i32[] _:i32[121989] _:i32[24650] t:i32[1935334] _:i32[24649] _:i32[24649]
            _:i32[24649] _:i32[24649] = scan[
            jaxpr={ lambda ; u:i32[] v:i32[121989] w:i32[24650] x:i32[1935334] y:i32[24649]
                z:i32[24649] ba:i32[24649] bb:i32[24649]. let
                bc:i32[] = add u 1
                bd:bool[] = lt u 0
                be:i32[] = add u 24649
                bf:i32[] = select_n bd u be
                bg:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bf
                bh:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] bg
                bi:i32[24649] = scatter[
                  dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
                  indices_are_sorted=True
                  mode=GatherScatterMode.FILL_OR_DROP
                  unique_indices=True
                  update_consts=()
                  update_jaxpr={ lambda ; bj:i32[] bk:i32[]. let  in (bk,) }
                ] bb bh u
                bl:bool[] = lt u 0
                bm:i32[] = add u 24649
                bn:i32[] = select_n bl u bm
                bo:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bn
                bp:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] bo
                bq:i32[] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(1,)
                  unique_indices=True
                ] y bp
                br:bool[] = lt bq 0
                bs:i32[] = add bq 1935334
                bt:i32[] = select_n br bq bs
                bu:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bt
                bv:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] bu
                bw:i32[] = convert_element_type[new_dtype=int32 weak_type=False] u
                bx:i32[1935334] = scatter[
                  dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
                  indices_are_sorted=True
                  mode=GatherScatterMode.FILL_OR_DROP
                  unique_indices=True
                  update_consts=()
                  update_jaxpr={ lambda ; bj:i32[] bk:i32[]. let  in (bk,) }
                ] x bv bw
                by:bool[] = lt u 0
                bz:i32[] = add u 24650
                ca:i32[] = select_n by u bz
                cb:i32[] = convert_element_type[new_dtype=int32 weak_type=False] ca
                cc:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] cb
                cd:i32[] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(1,)
                  unique_indices=True
                ] w cc
                ce:i32[] = add u 1
                cf:bool[] = lt ce 0
                cg:i32[] = add ce 24650
                ch:i32[] = select_n cf ce cg
                ci:i32[] = convert_element_type[new_dtype=int32 weak_type=False] ch
                cj:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] ci
                ck:i32[] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(1,)
                  unique_indices=True
                ] w cj
                _:i32[] _:i32[] _:i32[] cl:i32[121989] cm:i32[24650] cn:i32[1935334]
                  co:i32[24649] cp:i32[24649] cq:i32[24649] cr:i32[24649] = while[
                  body_jaxpr={ lambda ; cs:i32[] ct:i32[] cu:i32[] cv:i32[121989]
                      cw:i32[24650] cx:i32[1935334] cy:i32[24649] cz:i32[24649] da:i32[24649]
                      db:i32[24649]. let
                      dc:i32[] = add cs 1
                      dd:bool[] = lt cs 0
                      de:i32[] = add cs 121989
                      df:i32[] = select_n dd cs de
                      dg:i32[1] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(1,)
                      ] df
                      dh:i32[] = gather[
                        dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                        fill_value=None
                        indices_are_sorted=True
                        mode=GatherScatterMode.PROMISE_IN_BOUNDS
                        slice_sizes=(1,)
                        unique_indices=True
                      ] cv dg
                      di:i32[] dj:i32[1935334] dk:i32[24649] _:i32[] dl:i32[24649]
                        dm:i32[24649] dn:i32[24649] = while[
                        body_jaxpr={ lambda ; do:i32[] dp:i32[1935334] dq:i32[24649]
                            dr:i32[] ds:i32[24649] dt:i32[24649] du:i32[24649]. let
                            dv:bool[] = lt dr 0
                            dw:i32[] = add dr 24649
                            dx:i32[] = select_n dv dr dw
                            dy:i32[1] = broadcast_in_dim[
                              broadcast_dimensions=()
                              shape=(1,)
                            ] dx
                            dz:i32[24649] = scatter[
                              dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
                              indices_are_sorted=True
                              mode=GatherScatterMode.FILL_OR_DROP
                              unique_indices=True
                              update_consts=()
                              update_jaxpr={ lambda ; bj:i32[] bk:i32[]. let
                                  
                                in (bk,) }
                            ] du dy do
                            ea:bool[] = lt dr 0
                            eb:i32[] = add dr 24649
                            ec:i32[] = select_n ea dr eb
                            ed:i32[1] = broadcast_in_dim[
                              broadcast_dimensions=()
                              shape=(1,)
                            ] ec
                            ee:i32[] = gather[
                              dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                              fill_value=None
                              indices_are_sorted=True
                              mode=GatherScatterMode.PROMISE_IN_BOUNDS
                              slice_sizes=(1,)
                              unique_indices=True
                            ] dt ed
                            ef:bool[] = lt ee 0
                            eg:i32[] = add ee 1935334
                            eh:i32[] = select_n ef ee eg
                            ei:i32[] = convert_element_type[
                              new_dtype=int32
                              weak_type=False
                            ] eh
                            ej:i32[1] = broadcast_in_dim[
                              broadcast_dimensions=()
                              shape=(1,)
                            ] ei
                            ek:i32[] = convert_element_type[
                              new_dtype=int32
                              weak_type=False
                            ] do
                            el:i32[1935334] = scatter[
                              dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
                              indices_are_sorted=True
                              mode=GatherScatterMode.FILL_OR_DROP
                              unique_indices=True
                              update_consts=()
                              update_jaxpr={ lambda ; bj:i32[] bk:i32[]. let
                                  
                                in (bk,) }
                            ] dp ej ek
                            em:bool[] = lt dr 0
                            en:i32[] = add dr 24649
                            eo:i32[] = select_n em dr en
                            ep:i32[1] = broadcast_in_dim[
                              broadcast_dimensions=()
                              shape=(1,)
                            ] eo
                            eq:i32[24649] = scatter-add[
                              dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
                              indices_are_sorted=True
                              mode=GatherScatterMode.FILL_OR_DROP
                              unique_indices=True
                              update_consts=()
                              update_jaxpr={ lambda ; er:i32[] es:i32[]. let
                                  et:i32[] = add er es
                                in (et,) }
                            ] dt ep 1
                            eu:bool[] = lt dr 0
                            ev:i32[] = add dr 24649
                            ew:i32[] = select_n eu dr ev
                            ex:i32[1] = broadcast_in_dim[
                              broadcast_dimensions=()
                              shape=(1,)
                            ] ew
                            ey:i32[] = gather[
                              dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                              fill_value=None
                              indices_are_sorted=True
                              mode=GatherScatterMode.PROMISE_IN_BOUNDS
                              slice_sizes=(1,)
                              unique_indices=True
                            ] ds ex
                          in (do, el, dq, ey, ds, eq, dz) }
                        body_nconsts=0
                        cond_jaxpr={ lambda ; ez:i32[] fa:i32[1935334] fb:i32[24649]
                            fc:i32[] fd:i32[24649] fe:i32[24649] ff:i32[24649]. let
                            fg:bool[] = lt fc ez
                            fh:bool[] = lt fc 0
                            fi:i32[] = add fc 24649
                            fj:i32[] = select_n fh fc fi
                            fk:i32[1] = broadcast_in_dim[
                              broadcast_dimensions=()
                              shape=(1,)
                            ] fj
                            fl:i32[] = gather[
                              dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,))
                              fill_value=None
                              indices_are_sorted=True
                              mode=GatherScatterMode.PROMISE_IN_BOUNDS
                              slice_sizes=(1,)
                              unique_indices=True
                            ] ff fk
                            fm:bool[] = ne fl ez
                            fn:bool[] = and fg fm
                          in (fn,) }
                        cond_nconsts=0
                      ] cu cx cy dh cz da db
                    in (dc, ct, di, cv, cw, dj, dk, dl, dm, dn) }
                  body_nconsts=0
                  cond_jaxpr={ lambda ; fo:i32[] fp:i32[] fq:i32[] fr:i32[121989]
                      fs:i32[24650] ft:i32[1935334] fu:i32[24649] fv:i32[24649] fw:i32[24649]
                      fx:i32[24649]. let
                      fy:bool[] = lt fo fp
                    in (fy,) }
                  cond_nconsts=0
                ] cd ck u v w bx y z ba bi
              in (bc, cl, cm, cn, co, cp, cq, cr) }
            length=24649
            linear=(False, False, False, False, False, False, False, False)
            num_carry=8
            num_consts=0
            reverse=False
            unroll=1
          ] 0 f g l h i k s
        in (t,) }
      name=symbolic_cholesky
    ] a b c d
  in (e,) }</code></pre>
</div>
</div>
<p>Success!</p>
<p>I guess we could ask ourselves if we gained any speed.</p>
<p>Here is the pure python code.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a><span class="im">import</span> timeit</span>
<span id="cb48-2"><a href="#cb48-2"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">20</span>)</span>
<span id="cb48-3"><a href="#cb48-3"></a>parent, col_count <span class="op">=</span> etree_base(A.indices, A.indptr)</span>
<span id="cb48-4"><a href="#cb48-4"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: symbolic_cholesky_base(A.indices, A.indptr, parent, col_count),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb48-6"><a href="#cb48-6"></a></span>
<span id="cb48-7"><a href="#cb48-7"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">50</span>)</span>
<span id="cb48-8"><a href="#cb48-8"></a>parent, col_count <span class="op">=</span> etree_base(A.indices, A.indptr)</span>
<span id="cb48-9"><a href="#cb48-9"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: symbolic_cholesky_base(A.indices, A.indptr, parent, col_count),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb48-11"><a href="#cb48-11"></a></span>
<span id="cb48-12"><a href="#cb48-12"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">200</span>)</span>
<span id="cb48-13"><a href="#cb48-13"></a>parent, col_count <span class="op">=</span> etree_base(A.indices, A.indptr)</span>
<span id="cb48-14"><a href="#cb48-14"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: symbolic_cholesky_base(A.indices, A.indptr, parent, col_count),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb48-15"><a href="#cb48-15"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And here is our JAX’d and JIT’d code.</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">20</span>)</span>
<span id="cb49-2"><a href="#cb49-2"></a>parent, col_count <span class="op">=</span> etree(A.indices, A.indptr)</span>
<span id="cb49-3"><a href="#cb49-3"></a></span>
<span id="cb49-4"><a href="#cb49-4"></a></span>
<span id="cb49-5"><a href="#cb49-5"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: symbolic_cholesky(A.indices, A.indptr, parent, col_count),number <span class="op">=</span> <span class="dv">1</span>, repeat <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb49-7"><a href="#cb49-7"></a></span>
<span id="cb49-8"><a href="#cb49-8"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">50</span>)</span>
<span id="cb49-9"><a href="#cb49-9"></a>parent, col_count <span class="op">=</span> etree(A.indices, A.indptr)</span>
<span id="cb49-10"><a href="#cb49-10"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: symbolic_cholesky(A.indices, A.indptr, parent, col_count),number <span class="op">=</span> <span class="dv">1</span>, repeat <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb49-11"><a href="#cb49-11"></a></span>
<span id="cb49-12"><a href="#cb49-12"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb49-13"><a href="#cb49-13"></a></span>
<span id="cb49-14"><a href="#cb49-14"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">200</span>)</span>
<span id="cb49-15"><a href="#cb49-15"></a>parent, col_count <span class="op">=</span> etree(A.indices, A.indptr)</span>
<span id="cb49-16"><a href="#cb49-16"></a>L_indptr <span class="op">=</span> np.zeros(A.shape[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb49-17"><a href="#cb49-17"></a>L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum(col_count)</span>
<span id="cb49-18"><a href="#cb49-18"></a></span>
<span id="cb49-19"><a href="#cb49-19"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: symbolic_cholesky(A_indices, A_indptr, L_indptr, parent, L_indptr[<span class="op">-</span><span class="dv">1</span>]),number <span class="op">=</span> <span class="dv">1</span>, repeat<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb49-20"><a href="#cb49-20"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb49-21"><a href="#cb49-21"></a></span>
<span id="cb49-22"><a href="#cb49-22"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">1000</span>)</span>
<span id="cb49-23"><a href="#cb49-23"></a>times <span class="op">=</span> timeit.repeat(<span class="kw">lambda</span>: etree(A.indices, A.indptr),number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb49-24"><a href="#cb49-24"></a><span class="bu">print</span>(<span class="ss">f"n = </span><span class="sc">{</span>A<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>[<span class="bu">round</span>(t,<span class="dv">2</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>If a person who actually knows how the JAX autodiff works happens across this blog, I’m so sorry.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>omg you guys. So many details<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>These are referred to as HLOs (Higher-level operations)<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Instead of doing one pass of reverse-mode, you would need to do <span class="math inline">\(d\)</span> passes of forwards mode to get the gradient with respect to a d-dimensional parameter.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Unlike <code>jax.lax.while</code>, which is only forwards differentiable, <code>jax.lax.scan</code> is fully differentiable.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>In general, if the function has state.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>This is the version of the symbolic factorisation that is most appropriate for us, as we will be doing a lot of Cholesky factorisations with the same sparstiy structure. If we rearrange the algorithm to the up-looking Cholesky decomposition, we only need the column counts and this is also called the symbolic factorisation. This is, incidentally, how Eigen’s sparse Cholesky works.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Actually it’s a forest<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Because we are talking about a tree, each child node has at most one parent. If it doesn’t have a parent it’s the root of the tree. I remember a lecturer saying that it should be called “father and son” or “mother and daughter” because every child has 2 parents but only one mother or one father. The 2000s were a wild time.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>These can also be computed in approxximately <span class="math inline">\(\mathcal{O(\text{nnz}(A))}\)</span> time, which is much faster. But the algorithm is, frankly, pretty tricky and I’m not in the mood to program it up. This difference would be quite important if I wasn’t storing the full symbolic factorisation and was instead computing it every time, but in my context it is less clear that this is worth the effort.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Python notation! This is rows/cols 0 to <code>j-1</code><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Python, it turns out, does not have a <code>do while</code> construct because, apparently, everything is empty and life is meaningless.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>The argument for JIT works by amortizing the compile time over several function evaluations. If I wanted to speed this algortihm up, I’d implement the more complex <span class="math inline">\(\mathcal{O}(\operatorname{nnz}(A))\)</span> version.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>Obviously it did not work the first time. A good way to debug JIT’d code is to use the python translations of the control flow literals. Why? Well for one thing there is an annoying tendency for JAX to fail silently when their is an out-of-bounds indexing error. Which happens, just for example, if you reolace <code>node = A_indices[indptr]</code> with <code>node = A_indices[A_indptr[indptr]]</code> because you got a text message half way through the line.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>We will still use the left-looking algorithm for the numerical computation. The two algorithms are equivalent in exact arithmetic and, in particular, have identical sparsity structures.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>I’m mixing 1-based indexing in the maths with 0-based in the code because I think we need more chaos in our lives.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>Yes. I know. I’m swapping the meaning of <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> but you know that’s because in a symmetric matrix rows and columns are a bit similar. The upper half of column $$ is the left half of row <span class="math inline">\(j\)</span> after all.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>If <code>mark[node]==j</code> then I have already found <code>node</code> and all of its anscestors in my sweep of row <code>j</code><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>This is because <code>L[j,node] != 0</code> by our logic.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div quarto-reuse="quarto-reuse" class="quarto-appendix-contents"><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">https://creativecommons.org/licenses/by-nc/4.0/</a></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{simpson2022,
  author = {Dan Simpson},
  editor = {},
  title = {Sparse Matrices Part 7: {Making} Peace with Those Weird {JAX}
    Loops},
  date = {2022-11-23},
  url = {https://dansblog.netlify.app/posts/2022-11-23-wrong-mcmc/wrong-mcmc.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-simpson2022" class="csl-entry quarto-appendix-citeas" role="doc-biblioentry">
Dan Simpson. 2022. <span>“Sparse Matrices Part 7: Making Peace with
Those Weird JAX Loops.”</span> November 23, 2022. <a href="https://dansblog.netlify.app/posts/2022-11-23-wrong-mcmc/wrong-mcmc.html">https://dansblog.netlify.app/posts/2022-11-23-wrong-mcmc/wrong-mcmc.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>